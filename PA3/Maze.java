// Name: Mingkai Cao// USC loginid: mingkaic// CS 455 PA3// Spring 2017import java.util.LinkedList;/**   Maze class   Stores information about a maze and can find a path through the maze   (if there is one).      Assumptions about structure of the maze, as given in mazeData, startLoc, and endLoc   (parameters to constructor), and the path:     -- no outer walls given in mazeData -- search assumes there is a virtual         border around the maze (i.e., the maze path can't go outside of the maze        boundaries)     -- start location for a path is maze coordinate startLoc     -- exit location is maze coordinate exitLoc     -- mazeData input is a 2D array of booleans, where true means there is a wall        at that location, and false means there isn't (see public FREE / WALL         constants below)      -- in mazeData the first index indicates the row. e.g., mazeData[row][col]     -- only travel in 4 compass directions (no diagonal paths)     -- can't travel through walls */public class Maze {   /**   @param mazeData : the data representing the Maze   @param mazePassed : record whether a loc is visited or not   @param foundOrNot : record whether a path is found   @param startLoc : start location   @param exitLoc : exit location   @param path : the founded path consisting of a series of loc   PRE: 1. mazeData.length > 0        2. 0 <= startLoc.getRow() < mazeData.length        3. 0 <= startLoc.getCol() < mazeData[0].length        4. 0 <= endLoc.getRow() < mazeData.length         5. 0 <= endLoc.getCol() < mazeData[0].length   */   public static final boolean FREE = false;   public static final boolean WALL = true;   private boolean[][] mazeData;   private boolean[][] mazePassed;   private boolean foundOrNot;   private MazeCoord startLoc;   private MazeCoord exitLoc;   private LinkedList<MazeCoord> path;   private final int DIR_OFFSET = 1;   private final int INVALID = -2;   private final int STOP = -1;   private final int FINISH =  1;   private final int CONTINUE = 0;   public  final boolean PASSED = true;   public  final boolean NOT_PASSED = false;   public  final boolean FOUND = true;   public  final boolean NOT_FOUND = false;        private int cnt = 0;   /**      Constructs a maze.      @param mazeData the maze to search.  See general Maze comments above for what      goes in this array.      @param startLoc the location in maze to start the search (not necessarily on an edge)      @param exitLoc the "exit" location of the maze (not necessarily on an edge)      PRE: 0 <= startLoc.getRow() < mazeData.length and 0 <= startLoc.getCol() < mazeData[0].length         and 0 <= endLoc.getRow() < mazeData.length and 0 <= endLoc.getCol() < mazeData[0].length    */   public Maze(boolean[][] mazeData, MazeCoord startLoc, MazeCoord exitLoc) {   	  this.mazeData = mazeData;      this.startLoc = startLoc;      this.exitLoc = exitLoc;      foundOrNot = NOT_FOUND;      int numRows = mazeData.length;       int numCols = mazeData[0].length;      path = new LinkedList<MazeCoord>();      mazePassed = new boolean[numRows][numCols];      for(int i = 0; i < numRows; i++){          for(int j = 0; j < numCols; j++){              mazePassed[i][j] = NOT_PASSED;          }      }   }   /**      Returns the number of rows in the maze      @return number of rows   */   public int numRows() {      return mazeData.length;   }      /**      Returns the number of columns in the maze      @return number of columns   */      public int numCols() {      return mazeData[0].length;   }        /**      Returns true iff there is a wall at this location      @param loc the location in maze coordinates      @return whether there is a wall here      PRE: 0 <= loc.getRow() < numRows() and 0 <= loc.getCol() < numCols()   */   public boolean hasWallAt(MazeCoord loc) {        int row = loc.getRow();        int col = loc.getCol();        boolean result = FREE;        result = mazeData[row][col];        return result;   }   /**      Returns the entry location of this maze.    */   public MazeCoord getEntryLoc() {      return startLoc;      }         /**     Returns the exit location of this maze.   */   public MazeCoord getExitLoc() {      return exitLoc;      }      /**      Returns the path through the maze. First element is start location, and      last element is exit location.  If there was not path, or if this is called      before a call to search, returns empty list.      @return the maze path    */   public LinkedList<MazeCoord> getPath() {      return path;    }   /**      Find a path from start location to the exit location (see Maze      constructor parameters, startLoc and exitLoc) if there is one.      Client can access the path found via getPath method.      @return whether a path was found.    */    public boolean search()  {        // if foundOrNot == NOT_FOUND , search the path        // if foundOrNot == FOUND , we can say search() was executed before        if(foundOrNot == NOT_FOUND){             // abnormal case 1: startLoc and exitLoc are walls, return NOT_FOUND            if( this.hasWallAt( startLoc ) || this.hasWallAt( exitLoc ) ){                return NOT_FOUND;            }            // abnormal case 2: startLoc and exitLoc are the same, return FOUND            if( startLoc.equals( exitLoc )){                path.push( startLoc );                path.push( exitLoc );                return FOUND;            }            // normal case            this.setPassed( startLoc );            path.push( startLoc );            findExit( startLoc, path );           }        return foundOrNot;    }   /**      Find a path from current location to the exit if there is one.      @param loc  current location      @param curPath path obtained by previous location    */   private void findExit(MazeCoord loc, LinkedList<MazeCoord> curPath){               int row = loc.getRow();        int col = loc.getCol();        MazeCoord locRight = new MazeCoord( row, col + DIR_OFFSET );        MazeCoord locLeft  = new MazeCoord( row, col - DIR_OFFSET );        MazeCoord locBelow = new MazeCoord( row + DIR_OFFSET, col );        MazeCoord locAbove = new MazeCoord( row - DIR_OFFSET, col );               this.cnt++;        findExitExtend( locRight,  curPath );        System.out.println(this.cnt + " : " + "Right" + " : " + locRight);        findExitExtend( locLeft,   curPath );        System.out.println(this.cnt + " : " + "Left" + " : " + locLeft);        findExitExtend( locAbove,  curPath );        System.out.println(this.cnt + " : " + "Above" + " : " + locAbove);        findExitExtend( locBelow,  curPath );        System.out.println(this.cnt + " : " + "Below" + " : " + locBelow);   }   /**      Extend the last location to one of its four direction :right/ left/ above/ below ,      and depending on status of this direction, find a path from here.      @param loc  current location      @param curPath path obtained by previous location    */   private void findExitExtend( MazeCoord loc,  LinkedList<MazeCoord> curPath){         switch( this.directionStatus(loc) ){              case INVALID : break;            case STOP    : break;            case CONTINUE: {    // copy the path obtained by the previous location                                LinkedList<MazeCoord> newPath = new LinkedList<MazeCoord>();                                int length = curPath.size();                                for(int i = length-1; i >=0; i--){                                    newPath.push( curPath.get(i) );                                }                                newPath.push( loc );                                this.setPassed( loc ); // set this loc as passes/ visited                                this.findExit( loc, newPath );                                break;                            }            case FINISH  : {                                curPath.push( loc );                                this.path = curPath;                                this.foundOrNot = FOUND;//                                MazeCoord c = this.path//                                while()                                System.out.println(this.toStringPath());                                System.out.println();                System.out.println();                System.out.println();                                break;                            }            default      : break;        }       return;   }   /**      determine the current status of the current location,      @param loc  current location      @return which kind of status the current location is    */   private int directionStatus(MazeCoord loc){        int row = loc.getRow();        int col = loc.getCol();        int numRows = this.numRows();        int numCols = this.numCols();        if(row < numRows && row >= 0 && col < numCols && col >=0){            if(loc.equals( exitLoc )){                return FINISH;            }else if( this.hasWallAt(loc) ){                return STOP;            }else if( this.isPassed(loc) ) {                return STOP;            }else{                 return CONTINUE;             }        }        return INVALID;   }   /**      determine whether the current location is passed/ visited or not      @param loc  current location      @return whether visited or not    */   private boolean isPassed( MazeCoord loc ){        int row = loc.getRow();        int col = loc.getCol();        return mazePassed[ row ][ col ];   }     /**      set the current location as visited      @param loc  current location    */   private void setPassed( MazeCoord loc ){        int row = loc.getRow();        int col = loc.getCol();        mazePassed[ row ][ col ] = PASSED;   }   /**      print out the maze       @return the result string    */   public String toString(){        String result = "------------\n" ;        int numRows = this.numRows();        int numCols = this.numCols();        for(int i = 0; i < numRows; i++){            for(int j = 0; j < numCols; j++){                result += (mazeData[i][j] == FREE) ? " 0 " : " 1 " ;            }            result += "\n\n";        }        result += " startLoc: " + startLoc + "\n";        result += " exitLoc : " + exitLoc + "\n";        result += " foundOrNot : " + foundOrNot + "\n";        result += " path: " + path + "\n";        result += "------------\n" ;        return result;   }   /**      print out the visited status of the current maze       @return the result string in array form    */   public String toStringMazePassed(){        String result = "------------\n" ;        int numRows = this.numRows();        int numCols = this.numCols();        for(int i = 0; i < numRows; i++){            for(int j = 0; j < numCols; j++){                result += (mazePassed[i][j] == PASSED) ? "    PASSED   " : " NOT_PASSED " ;            }            result += "\n\n";        }        result += "------------\n" ;        return result;   }   /**      print out the current obtained path       @return the result string in linkedlist form    */   public String toStringPath(){        String result = "Path: \n" ;        int length = this.path.size();        for(int i = length -1 ; i >= 1 ; i--){            MazeCoord loc = this.path.get(i);            result += "[" + loc.getRow() + "," + loc.getCol() +"] --->";        }        if( length > 0 ){            MazeCoord loc = this.path.get(0);            result += "[" + loc.getRow() + "," + loc.getCol() +"]";        }        return result;   }}